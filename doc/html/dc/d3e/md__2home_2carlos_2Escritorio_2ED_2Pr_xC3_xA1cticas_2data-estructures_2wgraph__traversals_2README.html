<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>data-estructures: Árbol Abarcador de un Grafo</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">data-estructures
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d3e/md__2home_2carlos_2Escritorio_2ED_2Pr_xC3_xA1cticas_2data-estructures_2wgraph__traversals_2README.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Árbol Abarcador de un Grafo</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="árbol-abarcador-de-un-grafo"></a> _© F.J. Madrid Cuevas (<a href="#" onclick="location.href='mai'+'lto:'+'fjm'+'ad'+'rid'+'@u'+'co.'+'es'; return false;">fjmad<span class="obfuscator">.nosp@m.</span>rid@<span class="obfuscator">.nosp@m.</span>uco.e<span class="obfuscator">.nosp@m.</span>s</a>) Estructuras de Datos. Grado de Ingeniería Informática. Universidad de Córdoba. España_</p>
<h1><a class="anchor" id="objetivo-1"></a>
Objetivo</h1>
<ul>
<li>Aprender a implementar el TAD Grafo.</li>
<li>Implementar los algoritmos para obtener el árbol abarcador en profundidad y en anchura de un grafo.</li>
<li>Implementar un algoritmo para realizar la ordenación topológico de un grafo dirigido acíclico.</li>
<li>Implementar el algoritmo de Prim para obtener el árbol abarcador de coste mínimo.</li>
<li>Implementar el algoritmo de Kruskal para obtener el árbol abarcador de coste mínimo.</li>
<li>Conocer y aprender a utilizar el TAD Disjoint-Set.</li>
<li>Implementar una función de comparación personaliza para el algoritmo std::sort.</li>
</ul>
<h1><a class="anchor" id="descripción-7"></a>
Descripción</h1>
<p>En esta práctica vamos a obtener árboles abarcadores de un grafo. Un árbol abarcador de un grafo, es un subgrafo conexo sin ciclos. Si el grafo no es conexo, obtendremos varios árboles abarcadores, uno para cada componente conexa del grafo.</p>
<h2><a class="anchor" id="árboles-abarcadores-en-profundidad-o-en-amplitud"></a>
Árboles abarcadores en profundidad o en amplitud</h2>
<p>De forma genérica podemos procesar un grafo siguiendo un esquema de “primero en profundidad” o “primero en amplitud”. En el procesado en profundidad, usaremos un esquema recursivo con procesado prefijo de los vértices. En el procesado en amplitud, usaremos un esquema iterativo usando una cola para realizar un procesado prefijo de los vértices.</p>
<h2><a class="anchor" id="ordenación-topológica-de-un-grafo-dirigido-acíclico"></a>
Ordenación topológica de un grafo dirigido acíclico</h2>
<p>Es una especialización de árbol abarcador en profundidad aplicado a un grafo dirigido acíclico donde el lado dirigido “u-&gt;v” significa: “u” es un prerrequisito para “v”. En este caso el procesado de los vértices es postfijo y el resultado es una lista de vértices donde si “u” es un prerrequisito para “v”, el vértice “u” aparecerá antes que “v” en la lista.</p>
<h2><a class="anchor" id="árbol-abarcador-de-coste-mínimo"></a>
Árbol abarcador de coste mínimo</h2>
<p>Se aplican en grafos ponderados y es, de todos los posibles árboles abarcadores, aquel cuya suma de pesos de los lados seleccionados sea la mínima posible (pueden existir varias soluciones todas con el mismo coste mínimo). Para obtener el árbol abarcador de coste mínimo vamos a implementar los algoritmos de Prim y Kruskal y comparar sus salidas. La implementación del algoritmo de Prim es directa a partir de la descripción que hemos visto en clase. Para implementar el algoritmo de Kruskal vamos a utilizar un TAD auxiliar para “colorear” los vértices del grafo. Este TAD es conocido como “Disjoint Set.” [1]. Supongamos que “ds” es un DisjointSet con tamaño el número de vértices del grafo. Inicialmente cada vértice tiene un “color” distinto (tiene su propio conjunto) y esto se hace con ds.make_set(v.label()) para todo vértice v del grafo. Después, durante el algoritmo, al seleccionar un lado que conecta dos vértices u&ndash;v, con ds.find(u.label()) tenemos el “color” del vértice u y con ds.find(v.label()) el “color” de v. Si sus colores son iguales, ese lado no nos interesará, pero si son distintos, ese lado pertenece al AAM y deberemos unir los conjuntos para formar uno solo con ds.join(u.label(), v.label()). Al final del algoritmo, todos los vértices deberían tener el mismo color. En caso contrario es porque el grafo no es conexo. Por otra parte, para ordenar la lista de lados, vamos a utilizar el algoritmo std::sort al que le daremos un functional (en [2] tienes un ejemplo) para que compare dos lados de forma que la lista quede ordenada de menor a mayor peso y, a igualdad de pesos, (a,b) &lt; (b,c) &lt; (b,d) donde a, b, c y d son las etiquetas de los vértices. Es interesante que compruebes que aunque se pueden obtener soluciones diferentes con Prim (usando distintos nodos origen) y Kruskal, todas tienen el mismo coste mínimo.</p>
<h1><a class="anchor" id="evaluación-6"></a>
Evaluación</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Test   </th><th class="markdownTableHeadCenter">Puntos    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>graph/test_graph graph/00_tests_vertex</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>graph/test_graph graph/01_tests_edge</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>graph/test_graph graph/02_tests_graph</code>   </td><td class="markdownTableBodyCenter">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>graph/test_graph graph/03_tests_graph_fold_unfold</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_traversals 01_tests_df</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_traversals 02_tests_bf</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_traversals 03_tests_ts</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_traversals 04_tests_prim</code>   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_traversals 05_tests_kruskal</code>   </td><td class="markdownTableBodyCenter">1   </td></tr>
</table>
<ul>
<li><b>Nota</b>: si el TAD Grafo ya hubiera sido implementado en otra práctica sólo se evaluarán los tests relativos a los árboles abarcadores escalando la puntuación [0, 5] al rango [0, 10].</li>
</ul>
<h1><a class="anchor" id="referencias-3"></a>
Referencias</h1>
<p>[1] [<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>]. [2] [<a href="http://www.cplusplus.com/reference/algorithm/sort/">http://www.cplusplus.com/reference/algorithm/sort/</a>]. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
