<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>data-estructures: Sopa de letras</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">data-estructures
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d1f/md__2home_2carlos_2Escritorio_2ED_2Pr_xC3_xA1cticas_2data-estructures_2alphabet__soup_2README.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sopa de letras</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="sopa-de-letras"></a> *© <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">F.J</a>. Madrid Cuevas (<a href="#" onclick="location.href='mai'+'lto:'+'fjm'+'ad'+'rid'+'@u'+'co.'+'es'; return false;">fjmad<span class="obfuscator">.nosp@m.</span>rid@<span class="obfuscator">.nosp@m.</span>uco.e<span class="obfuscator">.nosp@m.</span>s</a>) Estructuras de Datos. Grado de Ingeniería Informática. Universidad de Córdoba. España*</p>
<h1><a class="anchor" id="objetivos-5"></a>
Objetivos</h1>
<ul>
<li>Aprender a implementar el TAD <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a>.</li>
<li>Aprender a usar un <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a> para resolver una sopa de letras.</li>
<li>Aprender a usar el tipo <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::map</a></li>
<li>Aprender a usar el tipo <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::pair</a></li>
<li>Aprender a usar el tipo <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::stack</a></li>
</ul>
<h1><a class="anchor" id="descripción-5"></a>
Descripción</h1>
<p>Un <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a> [1] es un árbol multicamino especializado en recuperar las claves almacenadas basándose en prefijos.</p>
<p>En un <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a> todo nodo (salvo la raíz) representa un prefijo de clave formado por el camino desde la raíz a dicho nodo y el subárbol que tiene a dicho nodo como raíz almacena todas las clave que tienen como prefijo el definido por el nodo raíz. En esta práctica, vamos a sacar partido de esta cualidad para resolver de forma eficiente una sopa de letras.</p>
<p>Como ya sabes, una sopa de letras es un tipo de puzle formado por una cuadrícula rellena con letras, de forma que, un número de palabras conocidas están contenidas en la cuadrícula siguiendo una secuencia lineal de casillas, sin que una casilla pueda estar compartida por dos o más palabras. El resto de casillas se rellenan con letras de forma aleatoria para “ocultar” a las palabras a buscar (ver Figura 1).</p>
<p>El juego consiste en localizar las palabras en el menor tiempo posible. La Figura 1 muestra un ejemplo de sopa de letras.</p>
<div style="margin-left: auto;
            margin-right: auto;
            width: 50%"></div><div style="margin-left: auto;
            margin-right: auto;
            width: 50%"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><img src="../../sopa_de_letras.jpg" alt="Ejemplo de sopa de letras" class="inline"/>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Figura 1.</b> Un ejemplo de sopa de letras. Se trata de localizar todas las naciones listadas. en la cuadrícula en el menor tiempo posible. Obtenida de: <a href="https://pasatiemposimprimibles.blogspot.com/2019/05/sopa-de-letras-de-nombres-de-paises-del.html">https://pasatiemposimprimibles.blogspot.com/2019/05/sopa-de-letras-de-nombres-de-paises-del.html</a>   </td></tr>
</table>
</div><div style="margin-left: auto;
            margin-right: auto;
            width: 50%"></div><p>Para resolver la sopa de letras, lo primero que tenemos que hacer es crear un <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a> insertando la lista de palabras a buscar como claves del <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a>.</p>
<p>Lo segundo sería ir recorriendo la cuadrícula (por filas y columnas), consultando en el <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a> si la letra de dicha cuadrícula es prefijo de alguna de alguna clave. Si es así aplicamos el algoritmo <code>scanCell</code> para analizar de forma recursiva la tabla a partir de una celda siguiendo un prefijo de clave.</p>
<p>Este algoritmo comienza o continua un escaneo a partir de la celda <code>(row, col)</code> siguiendo la dirección <code>(dy, dx)</code>. El resultado se almacena en un <code>Par</code> cuyo primer item es la palabra clave encontrada y el segundo item es una pila con las coordenadas de las celdas de la sopa donde está dicha la palabra clave.</p>
<div style="border: solid;
            margin-left: auto;
            margin-right: auto;
            width: 90%"></div><div style="border: solid;
            margin-left: auto;
            margin-right: auto;
            width: 90%"> Algorithm scanCell(row:Int, col:Int, dx:Int, dy:Int, trie:Trie, 
                        soup:AlphabetSoup, result:Pair[String, 
                        Stack[Pair[Int,Int]]]) //1. If the trie's prefix is a key then // a word is found. Save the key as the first item of the scan_result // pair and return from this level of recursion. //2. Else, we can two cases: //2.<a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">1.1</a> (dx==dy==0) The cell (row,col) is the first letter of a word. // If there is a sub-trie whose prefix is this symbol, start a new // recursive scanning of the 3x3 neighborhood from this position // using this sub-trie. //2.<a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">1.2</a> (dx!=0 or dy!=0) The cell (row,col) is the next letter of a // started scanning following the direction (dx,dy). If there is a // sub-trie whose prefix is this symbol, continue the scanning // following the direction (dx,dy) recursively. //2.2 After recursion comes back, if a word was found (first item of // the scan_result pair != ""), push the current cell's coordinates // (row,col) into the second item of scan_result (the stack of // coordinates).</div><div style="border: solid;
            margin-left: auto;
            margin-right: auto;
            width: 90%"></div><p>Así si utilizamos la sopa de la Figura 1, cuando estudiemos la celda (9,5) con valor ‘e’, el <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a> dirá que hay un prefijo ‘e’ (prefijo de clave ‘ecuador’) y pasaremos a llamar a nuestro algoritmo de escaneo del entorno de la celda (dy=0, dx=0) y usando el sub-trie con prefijo “e”. De esta forma (como (dy=0, dx=0)) se procederá a escanear ahora para el rango rows={8,9,5} x cols={4,5,6} (salvo la central (9,5)).</p>
<p>En este proceso al estudiar la celda (9,6) con valor ‘c’, el trie indica que hay un sub-trie con prefijo prefix()+“c”, por lo que se aplica de forma recursiva el algoritmo sobre el este sub-trie (representa el prefijo “ec”) a partir de la celda (9,6) con dirección dy=(9-9)=0 y dx=(6-5)=1.</p>
<p>Observa cómo a partir de la segunda letra encontrada (“c”), la dirección (dy=0,dx=1) indica ya la dirección a seguir para el resto de la palabra, es decir, en el resto de llamadas recursivas ya sólo se estudiarán las celdas (9+dy=9, 6+dx=7)=”u”. (9+dy=9, 7+dx=8)=”a”, … , y se repite el proceso hasta que se llega a un trie cuyo prefijo es clave (“ecuador”) pasando a inicializar el primer item del Par scan_result a “ecuador” indicando esto que se ha encontrado una palabra. Ahora antes de retornar de un nivel de recursión si se ha encontrado una palabra hay que apilar las coordenadas (row,col) de este nivel en la pila almacenada como segundo item del Par scan_result.</p>
<h1><a class="anchor" id="detalles-de-implementación"></a>
Detalles de implementación.</h1>
<p>Para representar el diccionario que asocia símbolo con nodo hijo vamos a utilizar el tipo <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::map</a> [2].</p>
<p>Para devolver el resultado de un escaneo de una palabra usaremos el tipo <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::pair</a> [3] de una cadena <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::string</a> y una pila <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::stack</a> [4]. La pila almacena a su vez pares (<a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::pair</a>) de enteros (fila,columna) con las coordenadas de la rejilla para cada letra de la palabra encontrada.</p>
<p>Para plegar/desplegar el símbolo que asocia un nodo padre con un nodo hijo vamos a utilizar una codificación en hexadecimal [5] codificando el código del símbolo con un entero sin signo de 16 bits [6].</p>
<h1><a class="anchor" id="evaluación-4"></a>
Evaluación</h1>
<div style="margin-left: auto;
            margin-right: auto;
            width: 50%"></div><div style="margin-left: auto;
            margin-right: auto;
            width: 50%"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Test   </th><th class="markdownTableHeadLeft">Puntos    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_trie_node tests_trie_node</code>   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_trie_node tests_trie_node_fold_unfold</code>   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_trie tests_trie</code>   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_trie tests_trie_fold_unfold</code>   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_trie tests_retrieve</code>   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_alphabet_soup_solver tests_alphabet_soup</code>   </td><td class="markdownTableBodyLeft">2   </td></tr>
</table>
</div><div style="margin-left: auto;
            margin-right: auto;
            width: 50%"></div><h1><a class="anchor" id="referencias-1"></a>
Referencias</h1>
<ul>
<li>[1] <a class="el" href="../../dc/d09/classTrie.html" title="Represents a Trie. A Trie is a m-path tree to store keys based on prefixes.">Trie</a>: <a href="http://en.wikipedia.org/wiki/Trie">http://en.wikipedia.org/wiki/Trie</a></li>
<li>[2] <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::map:</a> <a href="http://www.cplusplus.com/reference/map/map/">http://www.cplusplus.com/reference/map/map/</a></li>
<li>[3] <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::pair:</a> <a href="https://www.cplusplus.com/reference/utility/pair/pair/">https://www.cplusplus.com/reference/utility/pair/pair/</a></li>
<li>[4] <a class="el" href="../../d6/d7c/classAVLTree.html#a9fab28b32e97ffc5e0f1a4ed3d9823b2" title="Create an empty AVLTree.">std::stack:</a> <a href="http://www.cplusplus.com/reference/stack/stack/">http://www.cplusplus.com/reference/stack/stack/</a></li>
<li>[5] Manipuladores de flujo: <a href="https://www.cplusplus.com/reference/library/manipulators/">https://www.cplusplus.com/reference/library/manipulators/</a></li>
<li>[6] Tipos estándar para enteros: <a href="https://www.cplusplus.com/reference/cstdint/">https://www.cplusplus.com/reference/cstdint/</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
